---
defaults:
  - scope:
      path: ""
      type: posts
    values:
      layout: single
      author_profile: true
      comments: true
      related: true

title: "모던 자바스크립트 (10) 배열"
excerpt: "모던 자바스크립트 (10) 배열"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - JS
tags:
  - [JS, 모던자바스크립트]
date: 2023-07-12
last_modified_at: 2023-07-12
---
# 배열
- 객체보다 배열이 순서를 고려하는 컬렉션에 적합하다. 
- 배열 요소의 자료형엔 제약이 없다.
- 배열은 원시 자료형이 아닌 객체형에 속하며 객체처럼 동작함 (참조를 통한 복사 등..)
- push와 pop은 배열 맨 뒤에 요소를 제거하거나 추가하는것에 그치지만 shift와 unshift는 제거 후 나머지 배열 요소들에 대한 인덱스를 수정, length 프로퍼티값 갱신 등으로 리소스가 더 많이 듦


# 배열의 메서드 
- arr.push(), 맨 끝에 요소를 추가함
- arr.pop(), 맨 뒤의 요소를 제거하고 제거한 요소를 반환함 

- arr.shift(), 제일 앞 요소를 꺼내 제거한후 남아있는 요소를 앞으로 밀어줌,
- arr.unshift() , 제일 앞에 요소를 추가함 

# 배열 반복문 
- 일반  for문은 당연히 사용 가능함.
```js
let test = ['park', 'kim', 'lee']
for (let key of test) {
    alert( test[key]) // park , kim , lee 
}

```
- for of 문은 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있음 , 배열의 요소를 대상으로 반복작업시 유용 

- 배열도 객체형이기 때문에 for in 문을 사용할수는 있지만 객체와 함께 사용할 때 최적화되어있어서 배열에 사용시 매우 느리다. 
- 이유로는 필요없는 프로퍼티 또한 순회 대상에 섞이기 때문이다. 
 
# 배열의 length
- 배열의 length는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값이다. 
```js
let test = [];

test[123] = 'park'
alert(test.length) // 124

let check = [1,2,3,4,5]

check.length = 2; // 요소 두개만 남기고 자름 
alert(check) // [1,2]

check.length = 5; // 본래 길이로 되돌리기 
alert(check[4]) // undefined , 삭제된 요소들이 복구되지 않음  
```
- 그래서 이렇게 강제로 123에 값을 집어넣으면 배열 안의 요소가 한개뿐이어도 124가 나오게 된다
- 이런 특징을 이용해서 arr.length = 0; 을 이용하여 빈 배열을 만들수도 있다.


# 배열의 toString
```js
let arr = [1,2,3]

alert(arr)   // 1,2,3
```
- toString을 사용시 쉼표로 구분한 문자열이 반환된다 
- 배열엔 Symbol.toPrimitive나 valueOf 메서드가 없음. 

# arr.splice(index [, deleteCount, elem1 , elemN])
- index는 요소를 지우기 시작할 index 위치 , 두번째 매개변수는 제거할 요소의 개수 , elem 은 배열에 추가할 요소
```js
let arr = [1,2,3,4,5]

arr.splice(0, 3 , 'park', 'kim')

alert(arr) // ['park', 'kim', 4,5]

let test = [1,2,5]

test.splice(-1, 0 , 3, 4) // 배열 -1 (맨 뒤에서부터 첫번째 요소) , 0개 삭제 , 3과 4 추가 
alert(test) // [1,2,3,4,5]
```

# arr.slice([start], [end]) 
- start 인덱스부터 end를 제외한 end 인덱스까지의 요소를 복사한 새로운 배열을 반환함 , 음수일경우 배열 끝에서부터의 요소 개수를 의미함 
```js
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (인덱스가 1인 요소부터 인덱스가 3인 요소까지를 복사(인덱스가 3인 요소는 제외))

alert( arr.slice(-2) ); // s,t (인덱스가 -2인 요소부터 제일 끝 요소까지를 복사)
```
- 인수를 하나도 넘기지 않고 호출하여 arr의 복사본을 만들 수 있음, 기존의 배열을 건드리지않고 배열을 조작해서 새로운 배열을 만들때 사용함 

# concat(arg1, argN)
- 기본 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가할 때
```js
let arr = [1,2] 
alert( arr.concat([3,4])) // [1,2,3,4]
```
- 배열의 요소를 복사해서 활용함, 유사배열 객체이더라도 통으로 복사되어 더해짐 
```js
let arr = [1,2]

let arrayLike = {
    0: "something",
    length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]

let arrayLike = {
    0: "something",
    1: "else",
    [Symbol.isConcatSpreadable]: true,
    length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```
- 유사 배열 객체에에서 객체는 분해되지않고 그대로 복사되어 object Object 로 나옴  
- Symbol.inConcatSpreadable 이라는 특수 프로퍼티가 있으면 concat은 객체를 배열처럼 취급함

