---
defaults:
  - scope:
      path: ""
      type: posts
    values:
      layout: single
      author_profile: true
      comments: true
      related: true

title: "모던 자바스크립트 (16) 나머지 매개변수와 스프레드 문법, 변수의 유효범위와 클로저"
excerpt: "모던 자바스크립트 (16) 나머지 매개변수와 스프레드 문법, 변수의 유효범위와 클로저"
toc: true
toc_sticky: true
toc_label: "목차"
categories:
  - JS
tags:
  - [JS, 모던자바스크립트]
date: 2023-07-14
last_modified_at: 2023-07-14
---
# 나머지 매개변수
```js
function test (val, idx, ...args) {
    
}
```
- 여기서 ...args 는 나머지 매개변수로 val과 idx외에 모든 매개변수를 args라는 배열로 받는것을 의미함
- 나머지 매개변수는 항상 마지막에 있어야함 

# argument 객체
- arguments 는 유사배열 객체로 인덱스를 통해 인수에 접근 가능
```js
function test() {
    alert( arguments.length, arguments[0])
}
```
- arguments 는 이터러블 객체로 for..of 문 사용가능함 , 
- 유사배열 객체라 배열 멧드 사용불가능 , 인수 전체를 담아서 나머지 매개변수처럼 인수의 일부만 사용할 수 없음
- 화살표함수에선 지원하지않음 

# 스프레드문법 
- 이터러블하다면 모두 사용 가능 
```js
let arr1 = [1,2,3,4]
let arr2 = [5,6,7,8]

let merged = [0, ...arr1 , ...arr2, 9]  // 0 부터 9까지 들어감

let string = 'hello'
alert([...str]) // h,e,l,l,o , 
```
- string 을 분해하는 작업은 Array.from(string) 을 사용해서도 가능하다, 
- Array.from은 유사배열 객체와 이터러블 객체 둘 다에 사용할 수 있다. 
- 스프레드 문법은 이터러블 객체에만 사용할 수 있다.

# 배열과 객체의 복사본 만들기 
- 스프레드 문법으로 배열과 객체를 복사할 수 있음 
```js
let arr = [1,2,3]
let arrCopy = [...arr]

// 배열 복사본의 요소가 기존 배열 요소와 진짜 같을까요?
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// 두 배열은 같을까요?
alert(arr === arrCopy); // false (참조가 다름)

// 참조가 다르므로 기존 배열을 수정해도 복사본은 영향을 받지 않습니다.
arr.push(4);
alert(arr); // 1, 2, 3, 4
alert(arrCopy); // 1, 2, 3

let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; // 객체를 펼쳐서 각 요소를 분리후, 매개변수 목록으로 만든 다음에
                          // 매개변수 목록을 새로운 객체에 할당함

// 객체 복사본의 프로퍼티들이 기존 객체의 프로퍼티들과 진짜 같을까요?
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// 두 객체는 같을까요?
alert(obj === objCopy); // false (참조가 다름)

// 참조가 다르므로 기존 객체를 수정해도 복사본은 영향을 받지 않습니다.
obj.d = 4;
alert(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
alert(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
```
- 스프레드 문법을 사용하면 객체나 배열을 간단하게 복사 가능하다 

# 변수의 유효범위와 클로저 
- js는 함수 지향 언어 , 
- 함수를 동적으로 생성가능 , 
- 생성한 함수를 다른 함수에 인수로 넘기기 가능, 
- 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있음 
- 함수 내부에서 함수 외부에 있는 변수에 접근 가능

해결할 문제들 
1. 함수가 생성된 이후에 외부 변수가 변경되면 새로운 값을 가져오나 생성 시점 이전의 값을 가져오나?
2. 매개변수를 통해 함수를 넘기고 이 함수를 멀리 떨어진 코드에서 호출할 때 무슨 일이 발생하는지, 함수는 호출되는 곳을 기준으로 외부 변수에 접근하는지?

# 중첩함수 
- 함수 내부에서 선언한 함수는  중첩함수라고 부름 
```js
function sayHiBye(firstName, lastName) {

    // 헬퍼(helper) 중첩 함수
    function getFullName() {
        return firstName + " " + lastName;
    }

    alert( "Hello, " + getFullName() );
    alert( "Bye, " + getFullName() );

}


function makeCounter() {
    let count = 0;

    return function() {
        return count++;
    };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
```
- 중첩함수는 새로운 객체의 프로퍼티 형태나 중첩함수 그 자체로 반환될 수 있음 
- 위처럼 리턴값자체가 헬퍼함수가 될 수도있다

# 렉시컬 환경 
1. 변수 
- js에서는 실행중인 함수 , 코드블록, 스크립트 전체는 렉시컬 환경이라고 불리는 내부 숨김 연관 객체를 가짐

# 두개로 구분되는 렉시컬 환경 
- 환경레코드 - 모든 지역 변수를 프로퍼티로 저장하고 있는 객체 , this 값과 같은 기타 정보도 저장 
- 외부 렉시컬 환경에 대한 참조 - 외부 코드와 연결됨 

- 변수는 특수 내부 객체인 환경 레코드의 프로퍼티이다. 
- 변수를 가져오거나 변경하는 것은 환경 레코드의 프로퍼티를 가져오거나 변경함을 의미함 

- 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경이라고 함
- 전역 렉시컬 환경은 외부 참조를 갖지 않음 , 외부 참조하려고 하면 Null

- 스크립트가 선언되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라감 (pre-populated)
- 이 때 변수의 상태는 특수 내부 상태 (special internal state) 'uninitialized' js 엔진은 이 상태의 변수를 인지하지만 let을 만나기 전까진 참조할 수 없음
- Let 이 나타나더라도 처음엔 Undefined  그 이후에 값이 할당됨 

렉시컬 환경은 이론상의 객체임, 코드를 사용해서 렉시컬 환경을 얻거나 조작은 불가능 

# 함수선언문 
- 함수는 변수와 마찬가지로 값임,
- 함수 선언문으로 선언한 함수는 일반 변수와는 달리 바로 초기화되는것이 차이점 
- 함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 있음, (변수는 Let을 만나서 선언될때까지 사용할 수 없음)
- 이러한 동작 방식은 함수 선언문으로 정의한 함수에만 적용되고 함수 표현식에서는 적용되지않음 


# 내부와 외부 렉시컬 환경 
- 함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어짐 , 
- 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역변수가 저장됨 
- 함수가 호출중인 동안엔 호출중인 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 가리키는 외부 렉시컬 환경을 가지게 됨 
- 내부 렉시컬 환경은 외부 렉시컬 환경에 대한 참조를 가짐 
- 코드에서 변수에 접근할 땐 먼저 내부 렉시컬 환경을 검색 범위로 잡음 , 
- 내부 렉시컬 환경에서는 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장함 , 이 과정은 검색범위가 전역 렉시컬 환경으로 확장될때까지 반복 
- 전역 렉시컬 환경에 도달할 때 까지 변수를 찾지 못하면 엄격모드에선 에러가 발생 , 비엄격모드에선 정의되지 않은 변수에 값을 할당하려고 하면 에러가 발생하는 대신 새로운 전역 변수가 만들어짐(하위호환성을 위해 남은 기능 )

단순히 내부렉시컬에서 못찾으면 외부 렉시컬로 가고 외부렉시컬의 내부렉시컬을 확인하고 없으면 외부 ..... 전역렉시컬 까지 확인 


# 함수를 반환하는 함수 
```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
```
- makeCounter() 를 호출하면 호출할 떄마다 새로운 렉시컬 환경 객체가 만들어지고 여기에 makeCounter를 실행하는데 필요한 변수들이 저장됨. 
- makeCounter() 를 호출할 때도 두개의 렉시컬 환경이 만들어짐 
- 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억함, 
- 함수는 [[Environment]] 라는 숨김 프로퍼티를 갖음 , 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장, 함수가 생성될 때 한번 값이 세팅되고 변하지 않음 


# 클로저 
- 외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수를 의미 
- 함수 본문에선 [[environment]]를 사용해 외부 변수에 접근함 
- js 는 모든 함수가 클로저임 

# 가비지컬렉션 
- 함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거됨. 함수와 관련된 변수는 이때 모두 사라짐, 함수 호출이 끝나면 관련 변수를 참조할 수 없는 이유 
- 호출이 끝난 후에도 여전히 도달 가능한 중첩함수가 있을 수 있음 , 이때는 중첩함수의 [[Environment]] 프로퍼티에 외부함수 렉시컬 환경에 대한 정보가 저장됨 

# 최적화 프로세스 
- 함수가 살아있는 동안엔 이론상으론 모든 외부 변수 역시 메모리에 유지 
- 디버깅시 최적화 과정에서 제거된 변수를 사용할 수 없는 점은 v8엔진의 주요 부작용 

